#include "SidReader.h"
//#include "sidspectro\\sidfile.h"
//#include "sidspectro\\c64.h"
int getPitch(float freq, int prevPitch);

unsigned char freqtbllo[] = {
  0x17,0x27,0x39,0x4b,0x5f,0x74,0x8a,0xa1,0xba,0xd4,0xf0,0x0e,
  0x2d,0x4e,0x71,0x96,0xbe,0xe8,0x14,0x43,0x74,0xa9,0xe1,0x1c,
  0x5a,0x9c,0xe2,0x2d,0x7c,0xcf,0x28,0x85,0xe8,0x52,0xc1,0x37,
  0xb4,0x39,0xc5,0x5a,0xf7,0x9e,0x4f,0x0a,0xd1,0xa3,0x82,0x6e,
  0x68,0x71,0x8a,0xb3,0xee,0x3c,0x9e,0x15,0xa2,0x46,0x04,0xdc,
  0xd0,0xe2,0x14,0x67,0xdd,0x79,0x3c,0x29,0x44,0x8d,0x08,0xb8,
  0xa1,0xc5,0x28,0xcd,0xba,0xf1,0x78,0x53,0x87,0x1a,0x10,0x71,
  0x42,0x89,0x4f,0x9b,0x74,0xe2,0xf0,0xa6,0x0e,0x33,0x20,0xff };

unsigned char freqtblhi[] = {
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x04,
  0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x06,0x07,0x07,0x08,
  0x08,0x09,0x09,0x0a,0x0a,0x0b,0x0c,0x0d,0x0d,0x0e,0x0f,0x10,
  0x11,0x12,0x13,0x14,0x15,0x17,0x18,0x1a,0x1b,0x1d,0x1f,0x20,
  0x22,0x24,0x27,0x29,0x2b,0x2e,0x31,0x34,0x37,0x3a,0x3e,0x41,
  0x45,0x49,0x4e,0x52,0x57,0x5c,0x62,0x68,0x6e,0x75,0x7c,0x83,
  0x8b,0x93,0x9c,0xa5,0xaf,0xb9,0xc4,0xd0,0xdd,0xea,0xf8,0xff };


SidReader::SidReader(Song &song, const char *path, double songLengthS, int subSong)
{
	sid::main(song, 1, &path, songLengthS, subSong);
	int fps = 60;
	song.marSong->ticksPerBeat = 24;
	float bpm = (float)fps * 60 / song.marSong->ticksPerBeat;
	song.marSong->tempoEvents[0].tempo = bpm;
	song.marSong->tempoEvents[0].time = 0;
	song.marSong->numTempoEvents = 1;
	song.tracks.resize(3);
	for (int i = 0; i < 3; i++)
	{
		song.tracks[i].ticks.resize(int(songLengthS * fps) + 1);
		sprintf_s(song.marSong->tracks[i + 1].name, MAX_TRACKNAME_LENGTH, "Channel %i", i + 1);
	}

	//SIDFile sidFile(path);
	//if (subSong > 0)
	//	sidFile.startsong = subSong;

	//C64 c64;
	//c64.LoadSIDFile(sidFile);
	//float timeS = 0;
	//float ticksPerSeconds = bpm / 60 * song.marSong->ticksPerBeat;
	//int oldTimeT = 0;
	//while (timeS < songLengthS)
	//{
	//	c64.MainLoop();
	//	int timeT = (int)(timeS * ticksPerSeconds);
	//	for (int i = 0; i < 3; i++)
	//	{
	//		for (int j = oldTimeT + 1; j < timeT; j++)
	//			song.tracks[i].ticks[j] = song.tracks[i].ticks[oldTimeT];
	//		RunningTickInfo &curTick = song.tracks[i].ticks[timeT];
	//		RunningTickInfo &prevTick = *song.tracks[i].getPrevTick(timeT);

	//		curTick.noteStart = prevTick.noteStart;
	//		SIDChannel ch = c64.sid.channel[i];
	//		if (ch.isPlaying() && ch.frequency >= 20)
	//		{
	//			//float fPitch = log2(ch.frequency / 20) * 12;
	//			//int pitch = (int)fPitch;
	//			//if (abs(fPitch - prevTick.notePitch) <= 0.5f)
	//			//{
	//				//float pitchFrac = fPitch - floor(fPitch);
	//			//}

	//			curTick.notePitch = getPitch(ch.frequency, prevTick.notePitch);
	//			curTick.notePitch = (int)(log2(ch.frequency / 20) * 12 + 0.5f);
	//			
	//			if (prevTick.vol == 0 || prevTick.notePitch != curTick.notePitch)
	//				curTick.noteStart = timeT;
	//			curTick.vol = 50;// (int)ch.amplitude;
	//		}
	//		else
	//			curTick.vol = 0;
	//	}
	//	oldTimeT = timeT;

	//	timeS = c64.getTime();
	//}
}

SidReader::~SidReader()
{
}

int getPitch(float freq, int prevPitch)
{
	float dist = 0x7fffffff;
	int newPitch;
	for (int d = 0; d < 96; d++)
	{
		int cmpfreq = freqtbllo[d] | (freqtblhi[d] << 8);
		
		if (abs(freq - cmpfreq) < dist)
		{
			dist = abs(freq - cmpfreq);
			// Favor the old note
			if (d == prevPitch)
				dist /= 1;
			newPitch = d;
		}
	}
	return newPitch;
}
